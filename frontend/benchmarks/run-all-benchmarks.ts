/**
 * Run All Performance Benchmarks
 *
 * Executes all performance benchmarks and generates a comprehensive report
 */

import { execSync } from 'child_process';
import { writeFileSync } from 'fs';
import { join } from 'path';
import { measureBuildPerformance, printBuildMetrics, saveMetrics } from './build-performance';

interface BenchmarkReport {
	timestamp: string;
	version: string;
	buildMetrics: {
		buildTime: number;
		bundleSize: number;
		chunkCount: number;
	};
	vitestBenchmarks: string;
	summary: {
		allTargetsMet: boolean;
		buildTimePass: boolean;
		bundleSizePass: boolean;
		dslGenerationPass: boolean;
	};
}

/**
 * Run Vitest benchmarks
 */
function runVitestBenchmarks(): string {
	console.log('\nüèÉ Running Vitest benchmarks...\n');

	try {
		const output = execSync('npm run bench', {
			cwd: process.cwd(),
			encoding: 'utf-8',
			stdio: 'pipe'
		});

		console.log(output);
		return output;
	} catch (error: any) {
		// Vitest bench may exit with code 0 even on success
		return error.stdout || 'Benchmark completed';
	}
}

/**
 * Get package version
 */
async function getPackageVersion(): Promise<string> {
	const fs = await import('fs/promises');
	const packageJsonPath = join(process.cwd(), 'package.json');
	const packageJsonContent = await fs.readFile(packageJsonPath, 'utf-8');
	const packageJson = JSON.parse(packageJsonContent);
	return packageJson.version;
}

/**
 * Analyze benchmark results
 */
function analyzeBenchmarkResults(buildMetrics: any, vitestOutput: string) {
	const buildTimeTarget = 10000; // 10s
	const bundleSizeTarget = 50 * 1024 * 1024; // 50MB

	const buildTimePass = buildMetrics.buildTime < buildTimeTarget;
	const bundleSizePass = buildMetrics.bundleSize < bundleSizeTarget;

	// Check if DSL generation is under 100ms
	const dslGenerationMatch = vitestOutput.match(/Generate YAML from 100 nodes.*?(\d+\.?\d*)\s*(ms|Œºs)/);
	let dslGenerationPass = false;

	if (dslGenerationMatch) {
		const time = parseFloat(dslGenerationMatch[1]);
		const unit = dslGenerationMatch[2];
		const timeMs = unit === 'Œºs' ? time / 1000 : time;
		dslGenerationPass = timeMs < 100;
	}

	return {
		buildTimePass,
		bundleSizePass,
		dslGenerationPass,
		allTargetsMet: buildTimePass && bundleSizePass && dslGenerationPass
	};
}

/**
 * Generate markdown report
 */
function generateMarkdownReport(report: BenchmarkReport): string {
	const date = new Date(report.timestamp).toLocaleString();

	return `# Performance Benchmark Report

**Version**: ${report.version}
**Date**: ${date}

## Summary

${report.summary.allTargetsMet ? '‚úÖ **All performance targets met!**' : '‚ö†Ô∏è **Some performance targets not met**'}

| Metric | Target | Actual | Status |
|--------|--------|--------|--------|
| Build Time | < 10s | ${(report.buildMetrics.buildTime / 1000).toFixed(2)}s | ${report.summary.buildTimePass ? '‚úÖ PASS' : '‚ùå FAIL'} |
| Bundle Size | < 50MB | ${formatBytes(report.buildMetrics.bundleSize)} | ${report.summary.bundleSizePass ? '‚úÖ PASS' : '‚ùå FAIL'} |
| DSL Generation (100 nodes) | < 100ms | See benchmarks | ${report.summary.dslGenerationPass ? '‚úÖ PASS' : '‚ùå FAIL'} |

## Build Metrics

- **Build Time**: ${(report.buildMetrics.buildTime / 1000).toFixed(2)}s
- **Bundle Size**: ${formatBytes(report.buildMetrics.bundleSize)}
- **Chunk Count**: ${report.buildMetrics.chunkCount} files

## Vitest Benchmarks

\`\`\`
${report.vitestBenchmarks}
\`\`\`

## Performance Targets

### Canvas Rendering
- **Target**: 60fps (< 16.67ms per frame) @ 100 nodes
- **Status**: See benchmark results above

### DSL Generation
- **Target**: < 100ms @ 100 nodes
- **Status**: ${report.summary.dslGenerationPass ? '‚úÖ Target met' : '‚ö†Ô∏è Target not met'}

### Build Performance
- **Build Time Target**: < 10s
- **Bundle Size Target**: < 50MB

## Baseline Established

This benchmark establishes a performance baseline for:
- Canvas rendering with varying node counts (10, 50, 100, 200)
- DSL generation performance (10-500 nodes)
- Node data processing operations
- Frontend build times and bundle sizes

Future performance regressions can be detected by comparing against this baseline.

---

*Generated by Performance Benchmarking Suite v${report.version}*
`;
}

function formatBytes(bytes: number): string {
	if (bytes === 0) return '0 Bytes';
	const k = 1024;
	const sizes = ['Bytes', 'KB', 'MB', 'GB'];
	const i = Math.floor(Math.log(bytes) / Math.log(k));
	return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Main execution
 */
async function main() {
	console.log('üöÄ Sentinel Performance Benchmarking Suite\n');
	console.log('‚ïê'.repeat(60));

	try {
		// 1. Run build performance test
		console.log('\nüì¶ Step 1: Build Performance\n');
		const buildMetrics = measureBuildPerformance();
		printBuildMetrics(buildMetrics);

		// 2. Run Vitest benchmarks
		console.log('\n‚ö° Step 2: Runtime Benchmarks\n');
		const vitestOutput = runVitestBenchmarks();

		// 3. Analyze results
		const summary = analyzeBenchmarkResults(buildMetrics, vitestOutput);

		// 4. Get version
		const version = await getPackageVersion();

		// 5. Generate report
		const report: BenchmarkReport = {
			timestamp: new Date().toISOString(),
			version,
			buildMetrics: {
				buildTime: buildMetrics.buildTime,
				bundleSize: buildMetrics.bundleSize,
				chunkCount: buildMetrics.chunkCount
			},
			vitestBenchmarks: vitestOutput,
			summary
		};

		// 6. Save results
		const reportPath = join(process.cwd(), 'benchmarks', 'performance-report.md');
		const jsonPath = join(process.cwd(), 'benchmarks', 'performance-report.json');

		const markdown = generateMarkdownReport(report);
		writeFileSync(reportPath, markdown);
		writeFileSync(jsonPath, JSON.stringify(report, null, 2));

		console.log('\n‚úÖ Benchmark suite completed!\n');
		console.log(`üìÑ Markdown report: ${reportPath}`);
		console.log(`üìä JSON report: ${jsonPath}`);

		// Print summary
		console.log('\n' + '‚ïê'.repeat(60));
		console.log('\nüìä Final Summary:\n');
		if (summary.allTargetsMet) {
			console.log('‚úÖ All performance targets met!');
		} else {
			console.log('‚ö†Ô∏è  Some performance targets not met:');
			if (!summary.buildTimePass) console.log('   ‚ùå Build time exceeds 10s');
			if (!summary.bundleSizePass) console.log('   ‚ùå Bundle size exceeds 50MB');
			if (!summary.dslGenerationPass) console.log('   ‚ùå DSL generation exceeds 100ms');
		}

		console.log('\n' + '‚ïê'.repeat(60) + '\n');

		process.exit(summary.allTargetsMet ? 0 : 1);
	} catch (error) {
		console.error('\n‚ùå Benchmark suite failed:', error);
		process.exit(1);
	}
}

// Run if executed directly
const isMainModule = import.meta.url === `file://${process.argv[1]}`;

if (isMainModule) {
	main();
}

export { main as runAllBenchmarks };
